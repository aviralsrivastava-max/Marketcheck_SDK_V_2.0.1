/* tslint:disable */
/* eslint-disable */
/**
 * Marketcheck APIs
 * One API serving data spanned across multiple verticals
 *
 * The version of the OpenAPI document: 2.01
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';

export const BASE_PATH = "https://api.marketcheck.com/v2".replace(/\/+$/, "");

export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

export interface RequestArgs {
    url: string;
    options: RawAxiosRequestConfig;
}

export class BaseAPI {
    protected configuration: Configuration | undefined;
    private interceptorsInstalled: boolean = false;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected axios: AxiosInstance = globalAxios) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath ?? basePath;

            // CRITICAL FIX: Create a new axios instance for each API instance to avoid
            // sharing interceptors across different API classes
            // Without this, all API instances share globalAxios and interceptors stack up
            if (axios === globalAxios) {
                this.axios = globalAxios.create(configuration.baseOptions);
            }

            // Install rate limit interceptors (only once per axios instance)
            if (!this.interceptorsInstalled) {
                this.installRateLimitInterceptors();
                this.interceptorsInstalled = true;
            }
        }
    }

    /**
     * Install axios interceptors for automatic rate limiting
     * @private
     */
    private installRateLimitInterceptors(): void {
        if (!this.configuration) {
            return;
        }

        const manager = this.configuration.rateLimitManager;

        // Request Interceptor - called BEFORE each request is sent
        this.axios.interceptors.request.use(
            async (config) => {
                // Wait for our turn (queues if rate limit reached)
                await manager.waitForTurn();
                return config;
            },
            (error) => {
                // Handle request setup errors
                manager.handleRequestError(error);
                return Promise.reject(error);
            }
        );

        // Response Interceptor - called AFTER each response is received
        this.axios.interceptors.response.use(
            (response) => {
                // Update rate limit state from response headers
                manager.updateFromResponse(response);
                return response;
            },
            async (error) => {
                // V2: Special handling for 429 Rate Limit errors with automatic retry
                if (error.response && error.response.status === 429) {
                    // Track retry count
                    const config = error.config;
                    config._retryCount = config._retryCount || 0;

                    // Max 3 retries for 429 errors
                    if (config._retryCount < 3) {
                        config._retryCount++;

                        // Pass 429 error to manager for tracking and backoff calculation
                        manager.handle429Error(error, error.response);

                        // Extract Retry-After header (in seconds)
                        const retryAfter = error.response.headers['retry-after'];
                        let retryDelay = 1000; // Default 1 second
                        const MAX_RETRY_DELAY = 60000; // Cap at 60 seconds

                        if (retryAfter) {
                            const retryAfterSeconds = parseInt(retryAfter, 10);

                            // Check if Retry-After is unreasonably large (indicates quota exhaustion)
                            if (retryAfterSeconds > 60) {
                                console.error(
                                    `[MarketCheck SDK] Retry-After too large (${retryAfterSeconds}s = ${(retryAfterSeconds / 86400).toFixed(1)} days). ` +
                                    `This indicates quota exhaustion or API limit. Capping retry at 60s and will likely fail.`
                                );
                                retryDelay = MAX_RETRY_DELAY;
                            } else {
                                retryDelay = retryAfterSeconds * 1000;
                            }
                        } else {
                            // Exponential backoff: 1s, 2s, 4s
                            retryDelay = 1000 * Math.pow(2, config._retryCount - 1);
                            // Add jitter (Â±20%)
                            const jitter = retryDelay * 0.2 * (Math.random() * 2 - 1);
                            retryDelay = retryDelay + jitter;
                        }

                        console.warn(
                            `[MarketCheck SDK] Retrying 429 error (attempt ${config._retryCount}/3) ` +
                            `after ${(retryDelay / 1000).toFixed(2)}s`
                        );

                        // Wait for retry delay
                        await new Promise(resolve => setTimeout(resolve, retryDelay));

                        // Retry the request
                        return this.axios(config);
                    } else {
                        // Max retries exceeded
                        console.error(
                            `[MarketCheck SDK] Max retries (3) exceeded for 429 error. Giving up.`
                        );
                        manager.handle429Error(error, error.response);
                    }
                } else if (error.response) {
                    // Other errors - just update state
                    manager.updateFromResponse(error.response);
                } else {
                    // Network errors
                    manager.handleRequestError(error);
                }

                // Transform to clean error message
                const cleanError = new MarketCheckApiError(error);
                return Promise.reject(cleanError);
            }
        );
    }
};

export class RequiredError extends Error {
    constructor(public field: string, msg?: string) {
        super(msg);
        this.name = "RequiredError"
    }
}

/**
 * Custom error class for MarketCheck API errors
 * Provides clean, formatted error messages
 */
export class MarketCheckApiError extends Error {
    public status?: number;
    public statusText?: string;
    public endpoint?: string;
    public apiMessage?: string;

    constructor(error: any) {
        // Create clean error message
        let message = 'MarketCheck API Error';

        if (error.response) {
            const status = error.response.status;
            const statusText = error.response.statusText || '';
            const endpoint = error.config?.url || 'unknown endpoint';
            const apiMessage = error.response.data?.message || error.response.data?.error;

            // Format based on error type
            if (status === 403) {
                message = `Access Denied: This API key does not have permission to access ${endpoint}`;
            } else if (status === 401) {
                message = `Authentication Failed: Invalid or missing API key`;
            } else if (status === 404) {
                message = `Not Found: The requested resource does not exist`;
            } else if (status === 422) {
                message = `Validation Error: ${apiMessage || 'Invalid request parameters'}`;
            } else if (status === 429) {
                message = `Rate Limit Exceeded: Too many requests. Please wait and try again.`;
            } else if (status >= 500) {
                message = `Server Error (${status}): The API server encountered an error`;
            } else {
                message = `API Error (${status}): ${statusText}`;
            }

            if (apiMessage && status !== 422) {
                message += `\nDetails: ${apiMessage}`;
            }

            super(message);
            this.status = status;
            this.statusText = statusText;
            this.endpoint = endpoint;
            this.apiMessage = apiMessage;
        } else if (error.request) {
            // Request was made but no response received
            message = 'Network Error: Unable to reach the MarketCheck API server';
            super(message);
        } else {
            // Something else happened
            message = `Request Error: ${error.message || 'Unknown error occurred'}`;
            super(message);
        }

        this.name = 'MarketCheckApiError';
    }
}

interface ServerMap {
    [key: string]: {
        url: string,
        description: string,
    }[];
}

export const operationServerMap: ServerMap = {
}
