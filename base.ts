/* tslint:disable */
/* eslint-disable */
/**
 * Marketcheck APIs
 * One API serving data spanned across multiple verticals
 *
 * The version of the OpenAPI document: 2.01
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';

export const BASE_PATH = "https://api.marketcheck.com/v2".replace(/\/+$/, "");

export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

export interface RequestArgs {
    url: string;
    options: RawAxiosRequestConfig;
}

export class BaseAPI {
    protected configuration: Configuration | undefined;
    private interceptorsInstalled: boolean = false;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected axios: AxiosInstance = globalAxios) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath ?? basePath;

            // Install rate limit interceptors (only once per axios instance)
            if (!this.interceptorsInstalled) {
                this.installRateLimitInterceptors();
                this.interceptorsInstalled = true;
            }
        }
    }

    /**
     * Install axios interceptors for automatic rate limiting
     * @private
     */
    private installRateLimitInterceptors(): void {
        if (!this.configuration) {
            return;
        }

        const manager = this.configuration.rateLimitManager;

        // Request Interceptor - called BEFORE each request is sent
        this.axios.interceptors.request.use(
            async (config) => {
                // Wait for our turn (queues if rate limit reached)
                await manager.waitForTurn();
                return config;
            },
            (error) => {
                // Handle request setup errors
                manager.handleRequestError(error);
                return Promise.reject(error);
            }
        );

        // Response Interceptor - called AFTER each response is received
        this.axios.interceptors.response.use(
            (response) => {
                // Update rate limit state from response headers
                manager.updateFromResponse(response);
                return response;
            },
            (error) => {
                // Update state even on error responses
                if (error.response) {
                    manager.updateFromResponse(error.response);
                } else {
                    manager.handleRequestError(error);
                }

                // Transform to clean error message
                const cleanError = new MarketCheckApiError(error);
                return Promise.reject(cleanError);
            }
        );
    }
};

export class RequiredError extends Error {
    constructor(public field: string, msg?: string) {
        super(msg);
        this.name = "RequiredError"
    }
}

/**
 * Custom error class for MarketCheck API errors
 * Provides clean, formatted error messages
 */
export class MarketCheckApiError extends Error {
    public status?: number;
    public statusText?: string;
    public endpoint?: string;
    public apiMessage?: string;

    constructor(error: any) {
        // Create clean error message
        let message = 'MarketCheck API Error';

        if (error.response) {
            const status = error.response.status;
            const statusText = error.response.statusText || '';
            const endpoint = error.config?.url || 'unknown endpoint';
            const apiMessage = error.response.data?.message || error.response.data?.error;

            // Format based on error type
            if (status === 403) {
                message = `Access Denied: This API key does not have permission to access ${endpoint}`;
            } else if (status === 401) {
                message = `Authentication Failed: Invalid or missing API key`;
            } else if (status === 404) {
                message = `Not Found: The requested resource does not exist`;
            } else if (status === 422) {
                message = `Validation Error: ${apiMessage || 'Invalid request parameters'}`;
            } else if (status === 429) {
                message = `Rate Limit Exceeded: Too many requests. Please wait and try again.`;
            } else if (status >= 500) {
                message = `Server Error (${status}): The API server encountered an error`;
            } else {
                message = `API Error (${status}): ${statusText}`;
            }

            if (apiMessage && status !== 422) {
                message += `\nDetails: ${apiMessage}`;
            }

            super(message);
            this.status = status;
            this.statusText = statusText;
            this.endpoint = endpoint;
            this.apiMessage = apiMessage;
        } else if (error.request) {
            // Request was made but no response received
            message = 'Network Error: Unable to reach the MarketCheck API server';
            super(message);
        } else {
            // Something else happened
            message = `Request Error: ${error.message || 'Unknown error occurred'}`;
            super(message);
        }

        this.name = 'MarketCheckApiError';
    }
}

interface ServerMap {
    [key: string]: {
        url: string,
        description: string,
    }[];
}

export const operationServerMap: ServerMap = {
}
